\section*{Введение}

В данной курсовой работе будут показаны возможности языка \texttt{C\#} в плане использования его, как функционального языка программирования.
В частности, будет сравнение алгоритмов вычисления одной и той же функции применяя разные парадигмы программирования.
Сравним оптимизацию хвостовой рекурсией, обычную рекурсию, императивный стиль (цикл), а так же воспользуемся стандартными средствами языка \texttt{C\#} для того, чтобы вычислить функцию, используя все ядра нашего процессора.

По сей день люди решают уравнения (находят корни уравнения), находят суммы или произведения рядов, поэтому данная работа является актуальной. Так же эта работа является в некотором роде учебной, так как исследуется то, что не было в курсе программирования.

Цель данной работы - изучение основ функциональной парадигмы программирования, применение принципов функционального программирования с помощью языка \texttt{C\#}.

Задачи:

\begin{itemize}
	\item Изучить литературу по данной теме.
	\item Изучить методы и алгоритмы решения задачи.
	\item Описать сложность для каждого представленного алгоритма в $O$-нотации.
\end{itemize}
\addcontentsline{toc}{section}{Введение}

\newpage
\section{Функциональная парадигма программирования}

\subsection{История}

Первый высокоуровневый функциональный язык программирования \texttt{LISP} был разработан в конце 1950-х годов для научных компьютеров серии \texttt{IBM 700/7000} Джоном Маккарти, когда он учился в Массачусетском технологическом институте (MIT). \cite{HistoryofLISP}

Язык обработки информации (\texttt{IPL}), 1956, иногда упоминается как первый функциональный язык программирования.
Это язык в стиле ассемблера для работы со списками символов. \cite{ModelsofMyLife}
В нём действительно есть понятие генератора, которое сводится к функции, которая принимает функцию в качестве аргумента, и, поскольку это язык уровня ассемблера, то код может быть данными, поэтому IPL можно рассматривать как язык, имеющий функции более высокого порядка.

В 1970-х годах Гай Л. Стил и Джеральд Джей Сассман разработали язык \texttt{Scheme}, и использовали его в своём курсе, основанном на книге 1985 года "Структура и интерпретация компьютерных программ"\cite{SICP}.
\texttt{Scheme} был первым диалектом \texttt{LISP}, который использовал лексическую область видимости и требовал оптимизацию хвостовой рекурсией, которые рекомендуются в функциональном программировании.
Книга обучает фундаментальными принципами компьютерного программирования, включая рекурсию, абстракцию, модульность, проектирование и реализация языков программирования. 
Именно из этой книги были взяты некоторые примеры.
Книга до сих поря является классикой жанра и её до сих пор преподают в самых известных высших заведениях США.

\subsection{Функциональное программирование}

Функциональное программирование - это:

\begin{itemize}
	\item парадигма программирования, характеризующаяся использованием математических функций и избеганием побочных эффектов.
	\item стиль программирования, который использует только чистые функции без побочных эффектов.
\end{itemize}

Побочные эффекты - это всё, что делает функция, кроме возврата значения, например:

\begin{enumerate}
	\item Отправка электронного письма.
	\item Чтение файла.
	\item Выполнение веб-запроса.
\end{enumerate}

Побочные эффекты приводят к тому, что программист не может предсказать, что произойдёт в его программе.

Чистые функции - это функции, которые зависят только от своих аргументов и не имеют никаких побочных эффектов.
Одни и те же аргументы всегда будут выдавать одно и то же возвращаемое значение.

Из определения можно подумать, что функциональные языки программирования не имеют грязных функций.
Но это не так - такой язык бесполезен в реальном мире.
Вход в мир грязных функций красиво реализован в языке Haskell, там для таких целей используются монады, с помощью которых мы делаем обёртку над грязным миром.

\subsection{Концепции}

В целом можно выделить несколько инструментов (концептов) функционального программирования, это:

\begin{itemize}
	\item Функции первого класса и функции высшего порядка.
	\item Чистые функции.
	\item Рекурсия.
	\item Строгая и нестрогая вычислительная система.
\end{itemize}

\subsubsection{Функции высшего и первого порядка}

В математике и компьютерных науках функция высшего порядка - это функция, которая выполняет по крайней мере одно из следующих действий:

\begin{itemize}
	\item принимает одну или несколько функций в качестве аргументов,
	\item возвращает функцию в качестве результата.
\end{itemize}

Все остальные функции являются функциями первого класса.

\subsubsection{Чистые функции}

Чистые функции (или выражения) не имеют побочных эффектов (прямая работа с памятью или вводом-выводом).
Это означает, что чистые функции обладают несколькими полезными свойствами, многие из которых могут быть использованы для оптимизации кода:

\begin{itemize}
	\item Если результат чистого выражения не используется, его можно удалить, не затрагивая другие выражения.
	\item Если вызывается чистая функция с аргументами, которые не вызывают побочных эффектов, результат остается постоянным по отношению к этому списку аргументов (иногда вызывается ссылочная прозрачность или идемпотентность), т.е. повторный вызов чистой функции с теми же аргументами возвращает тот же результат. (Это может быть использовано для оптимизацией кэшированием)
	\item Если между двумя чистыми выражениями нет зависимости от данных, их порядок может быть изменен на противоположный, или они могут выполняться параллельно, и они не могут мешают друг другу (другими словами, вычисление любого чистого выражения является потокобезопасным).
	\item Если весь язык не допускает побочных эффектов, то можно использовать любую стратегию вычисления (следующая концепция, которую мы рассмотрим); это дает компилятору свободно изменять порядок или комбинировать вычисление выражений в программе (компилятор может так применить дефорестацию - избегание построения новых структур данных в программе).
\end{itemize}

\subsubsection{Рекурсия}

Итерация (цикл) в функциональных языках обычно выполняется с помощью рекурсии.
Рекурсивные функции вызывают сами себя, позволяя повторять операцию до тех пор, пока она не достигнет базового варианта.
В общем случае рекурсия требует поддержания стека, который потребляет пространство в линейной зависимости от глубины рекурсии.
Это может сделать рекурсию непомерно дорогой для использования вместо императивных циклов.
Однако особая форма рекурсии, известная как хвостовая рекурсия, может быть распознана и оптимизирована компилятором в том же коде, который использовался для реализации итерация в императивных языках.
Оптимизация хвостовой рекурсии может быть реализована, среди прочего, путем преобразования программы в стиль передачи продолжения во время компиляции.

\subsubsection{Стратегия вычисления}

Функциональные языки можно классифицировать по тому, используют ли они строгое (незамедлительное) или нестрогое (ленивое) вычисление, это понятия, которые относятся к тому, как аргументы функций вычисляются при вычислении самой функции.

Например:

\begin{code}
	\inputminted[tabsize=2,breaklines]{python}{src/evaluation.py}
\end{code}

Данное выражение не проходит строгое вычисление из-за деления на ноль в третьем элементе списка.
При ленивом вычислении функция длины возвращает значение 4 (т.е. количество элементов в списке), поскольку при ее вычислении не предпринимается попытка вычисления внутренних выражений, составляющие список.
Короче говоря, строгая оценка всегда полностью оценивает аргументы функции перед вызовом функции.
Ленивая оценка не вычисляет аргументы функции, если только их значения не требуются для вычисления самой функции.


\newpage
\section{Выбор программного обеспечения}

\subsection{Язык программирования}

Так как идея разработки пришла из прочтения книг про функциональное программирование, то и было бы логично применять в данной работе языки, которые являются либо частично функциональными, либо чисто функциональными.

Но одно из требований написания курсовой работы - применять язык программирования \texttt{C\#}, который не является функциональным.
В нём есть инструменты, с помощью которых можно писать функциональные методы, но это приходится всё обёртывать в статические классы, которые служат собой обычным именованным пространством.

Из-за требований работы невозможно рассматривать альтернативу \texttt{C\#}.

На данный момент существует функциональный язык программирования \texttt{F\#}, который может запускать \texttt{C\#} код.

\subsection{Операционная система}

На сегодняшний день почти все языки программирования имеют кроссплатформенную поддержку почти всех популярных операционных систем (\texttt{BSD}, \texttt{Windows}, \texttt{Linux}, \texttt{MacOS}).

Разработка велась на операционной системе \texttt{Windows 10}.

\subsection{Инструменты}

В качестве инструмента написания программ было выбрано несколько программ:

\begin{itemize}
	\item \texttt{Microsoft Visual Studio}
	\item \texttt{Microsoft Visual Studio Code}
	\item \texttt{JetBrains Rider}
\end{itemize}

\texttt{Microsoft Visual Studio} поставляет компилятор и интерпретатор для языка \texttt{C\#} под операционную систему \texttt{Windows}.

\texttt{Microsoft Visual Studio Code} является легковесным редактором текста.
В нём есть удобные расширения, с помощью которых я исправлял грамматические ошибки в комментариях к каждому методу.

\texttt{JetBrains Rider} является моим основным средством разработки.
Платный, но для студентов предоставляется студенческая бесплатная лицензия.
В этой среде разработки имеется удобный дебаггер, статический анализатор кода, который помогает найти ошибки в коде.
Удобные подсказки и автозаполнение кода увеличивают скорость и качество разработки кода.

В качестве системы контроля версий был выбран \texttt{Git}.
Является стандартом в современной разработке софта.
Весь текст курсовой работы и сам проект находится на сервисе \texttt{GitHub} (\url{https://github.com/andreymlv/coursework-functional-programming-in-charp}).

\newpage
\section{Проектирование}

При проектировании были использованы некоторые аспекты гибкой методологии разработки программного обеспечения.

В частности, была установлена основная функциональность проекта:

\begin{enumerate}
	\item Разработка функций высшего порядка, которые вычисляли сумму или произведение рядов любых функций.
	\item Разработка двух методов решения уравнений (метод Ньютона и метод бисекций).
	\item Разработка оптимизации хвостовой рекурсией.
\end{enumerate}

Разработка функций высшего порядка не является трудоёмкой задачей. 
Программисту необходимо сделать обёртку над какой-то общей идеей, чтобы пользователь данного кода думал об этих функциях, как о неком интерфейсе взаимодействия.

Например, вычисление суммы ряда. В данной курсовой работе есть целых 4 стратегии вычисления. Эти стратегии и будут аргументами, которые будут передаваться в параметры функции вычисления суммы некого ряда.
В нашем примере это будет: обычная рекурсия, "рекурсия" с использованием оптимизации хвостовой рекурсией, обычный цикл, и с использованием стандартных средств \texttt{DotNet} распараллеливание.

Или, вычисление корней уравнения: в данной работе показано, как можно использовать метод нахождения неподвижной функции для поиска корня уравнения.
Проблема в том, что не каждая функция сходится, когда мы ищем неподвижную точку.
Поэтому нам нужны дополнительные стратегии, или, назовём их иначе - помощники, которые помогут вычислить эту самую неподвижную точку функции.
В нашем примере это будет: метод касательных (или метод Ньютона) и метод торможения усреднением.

Оптимизация хвостовой рекурсии является задачей компилятора.
Но не все компиляторы поддерживают данную возможность из-за того, что язык первоначально не был спроектирован для того, чтобы использовать рекурсию, как механизм цикла.
В \texttt{C\#} данную оптимизацию можно реализовать с помощью \texttt{trampoline}, это фрагмент кода, который многократно вызывает функции. 
Когда функция должна выполнить вызов другой функции, вместо того, чтобы вызывать ее напрямую, а затем возвращать результат, она возвращает адрес функции и параметры вызова возвращаются к \texttt{trampoline} (из которого он был вызван сам), и \texttt{trampoline} заботится о следующем вызове этой функции с заданными параметрами. Это гарантирует, что стек не растет и цикл может продолжаться бесконечно.

\subsection{Трансформация кода в цикл}
\label{transformation}

Хвостовая рекурсия может быть связана с оператором \texttt{while}, явной итерацией, например, путем преобразования:

\begin{minted}[tabsize=2]{python}
def foo(x):
	if p(x):
		return bar(x)
	else:
		return foo(baz(x))
\end{minted}

в

\begin{minted}[tabsize=2]{python}
def foo(x):
	while true:
		if p(x):
			return bar(x)
		else:
			x = baz(x)
\end{minted}

\subsection{Алгоритм вычисления ряда}

По-сути алгоритм такой: в цикле накапливаем результат. Примитивный алгоритм имеет сложность $O(n)$.

\subsection{Численные методы решения нелинейных уравнений}

\subsubsection{Метод бисекции или метод деления отрезка пополам}

Метод бисекции или метод деления отрезка пополам — простейший численный метод для решения нелинейных уравнений вида $f(x)=0$. Предполагается только непрерывность функции $f(x)$. Поиск основывается на теореме о промежуточных значениях.

Задача заключается в нахождении корней нелинейного уравнения $f(x)=0$.

Для начала итераций необходимо знать отрезок $[x_L, x_R]$, значений $x$, на концах которого функция принимает значения противоположных знаков.

Противоположность знаков значений функции на концах отрезка можно определить множеством способов. Один из множества этих способов — умножение значений функции на концах отрезка и определение знака произведения путём сравнения результата умножения с нулём: $f(x_L)*f(x_R)<0$, в действительных вычислениях такой способ проверки противоположности знаков при крутых функциях приводит к преждевременному переполнению.
Для устранения переполнения и уменьшения затрат времени, то есть для увеличения быстродействия, на некоторых программно-компьютерных комплексах противоположность знаков значений функции на концах отрезка нужно определять по формуле:
$sign(f(x_L)) \neq sign(f(x_R))$, так как одна операция сравнения двух знаков двух чисел требует меньшего времени, чем две операции: умножение двух чисел (особенно с плавающей запятой и двойной длины) и сравнение результата с нулём. При данном сравнении, значения функции $f(x)$ в точках $x_L$ и $x_R$ можно не вычислять, достаточно вычислить только знаки функции $f(x)$ в этих точках, что требует меньшего машинного времени.

Из непрерывности функции $f(x)$ и условия противоположности знаков следует, что на отрезке $[x_{L},x_{R}]$ существует хотя бы один корень уравнения (в случае не монотонной функции $f(x)$ функция имеет несколько корней и метод приводит к нахождению одного из них).

Найдём значение $x$ в середине отрезка:$x_{M}=(x_{L}+x_{R})/2$, в действительных вычислениях, для уменьшения числа операций, в начале, вне цикла, вычисляют длину отрезка по формуле:$x_{D}=(x_{R}-x_{L})$, а в цикле вычисляют длину очередных новых отрезков по формуле: $x_{D}=x_{D}/2$ и новую середину по формуле:$x_{M}=x_{L}+x_{D}$.

Вычислим значение функции $f(x_{M})$ в середине отрезка $x_M$:

Если $f(x_{M})=0$ или, в действительных вычислениях, $|f(x_{M})|\leq \varepsilon _{{f(x)}}$, где $\varepsilon _{{f(x)}}$ - заданная точность по оси y, то корень найден.
Иначе $f(x_{M})\neq 0$ или, в действительных вычислениях, $|f(x_{M})|>\varepsilon _{{f(x)}}$, то разобьём отрезок $[x_{L},x_{R}]$ на два равных отрезка: $[x_{L},x_{M}]$ и $[x_{M},x_{R}]$.

Теперь найдём новый отрезок, на котором функция меняет знак:

\begin{itemize}
	\item Если значения функции на концах отрезка имеют противоположные знаки на левом отрезке, $f(x_{L})\cdot f(x_{M})<0$ или $sign(f(x_{L}))\neq sign(f(x_{M}))$, то, соответственно, корень находится внутри левого отрезка $[x_{L},x_{M}]$. Тогда возьмём левый отрезок присвоением $x_{R}=x_{M}$, и повторим описанную процедуру до достижения требуемой точности $\varepsilon _{{f(x)}}$ по оси $y$.
	\item Иначе значения функции на концах отрезка имеют противоположные знаки на правом отрезке, $f(x_{M})\cdot f(x_{R})<0$ или $sign(f(x_{M}))\neq sign(f(x_{R}))$, то, соответственно, корень находится внутри правого отрезка $[x_{M},x_{R}]$. Тогда возьмём правый отрезок присвоением $x_{L}=x_{M}$, и повторим описанную процедуру до достижения требуемой точности $\varepsilon _{f(x)}$ по оси $y$.
\end{itemize}

За количество итераций $N$ деление пополам осуществляется $N$ раз, поэтому длина конечного отрезка в $2^N$ раз меньше длины исходного отрезка. Получаем сложность $O(\log N)$.

\subsubsection{Неподвижная точка и метод Ньютона}

Неподвижная точка в математике — точка, которую заданное отображение переводит в неё же, иными словами, решение уравнения $f(x)=x$.

К примеру, отображение $f(x)=x^2-3x+3$ имеет неподвижные точки $x=1$ и $x=3$, поскольку $f(1)=1$ и $f(3)=3$.

Неподвижные точки есть не у всякого отображения — скажем, отображение $f(x)=x+1$ вещественной прямой в себя неподвижных точек не имеет.

Точки, возвращающиеся в себя после определённого числа итераций, то есть, решения уравнения $f(f(\dots f(x)\dots))=x$,  называются периодическими (в частности, неподвижные точки — это периодические точки периода $1$).

Одним из применений идеи притягивающей неподвижной точки является метод Ньютона: решение уравнения оказывается притягивающей неподвижной точкой некоторого отображения, и потому может быть найдено как предел очень быстро сходящейся последовательности чисел, полученных его повторным применением.

Основная идея метода заключается в следующем: задаётся начальное приближение вблизи предположительного корня, после чего строится касательная к графику исследуемой функции в точке приближения, для которой находится пересечение с осью абсцисс. Эта точка берётся в качестве следующего приближения. И так далее, пока не будет достигнута необходимая точность.

В этом случае алгоритм нахождения численного решения уравнения $f(x)=0$ сводится к итерационной процедуре вычисления: $x_{n+1}=x_{n}-{\frac {f(x_{n})}{f'(x_{n})}}$. По теореме Банаха последовательность приближений стремится к корню уравнения $f(x)=0$.

Наиболее известным примером применения этого метода является нахождение квадратного корня из числа $a \geq 0$ как предела итераций отображения $f(x)=\cfrac{x+\frac{a}{x}}{2}$.

\newpage
\section{Разработка}

Первым делом будет показан интерфейс взаимодействия, а после будет показано и рассказаны детали реализации.

Для демонстрации мощности функционального программирования я создал статический класс Accumulate, который является модулем, в котором есть функции нахождения суммы/произведения рядов. 

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Library/Accumulate.cs}
	\caption{\texttt{Accumulate.cs} - Статический класс для создания любых рядов.}
\end{code}

Такой класс создаёт больше поле стратегий для вычислений любого ряда.

Можно задать любой шаг. Можно задать любую функцию, которая описывает общий элемент последовательности. Любой знак между общими членами. Любой аккумулятор, который будет накапливать значение.

Таким образом можно создать класс, который "реализует" некоторые части нашей последовательности. Например, класс "сумма ряда":

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Library/Sum.cs}
	\caption{\texttt{Sum.cs} - Статический класс для создания любых рядов суммы.}
\end{code}

Как видим мы используем функции высшего порядка. Мы передаём в качестве аргументов "стратегию" вычисления суммы.
В юнит-тестах показано, как использовать данных класс.
Аналогичным образом был разработал класс "произведения ряда":

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Library/Product.cs}
	\caption{\texttt{Product.cs} - Статический класс для создания любых рядов произведения.}
\end{code}

Эти классы показывают как можно легко построить систему, в основе которой лежит более общая "идея".
Идея суммы ряда это частный случай любой последовательности.

Далее стоит обратить своё внимание на то, как реализована оптимизация хвостовой рекурсией, потому что в самом компиляторе и интерпретаторе кода \texttt{C\#} нет такой оптимизации.
Как было уже ранее показано в пункте \ref{transformation}, любая примитивная рекурсия может быть трансформирована в цикл.

Для того, чтобы передавать в trampoline нашу рекурсию, программисту необходимо определить функцию-помощника \texttt{RecursiveInvokeHelper}, которая являлась бы обёрткой той реализации, которую программист написал бы без оптимизации. 
Базовый случай рекурсии необходимо вызвать как \texttt{TailRecursion.Return(\dots)}, а общий случай необходимо вызывать как исполнение нашей функции, передав её, как лямбда-функцию \\ \texttt{TailRecursion.Next(() => RecursiveInvokeHelper(\dots))}. 
Далее, чтобы начать исполнение нашей рекурсии нам надо вызвать код, который передаст все аргументы и функции в trampoline: \texttt{TailRecursion.Execute(() => RecursiveInvokeHelper(\dots))}. \\ И когда \texttt{Execute} начнёт своё выполнение, то он развернёт рекурсию в бесконечный цикл, который прервётся только при выдаче нашей рекурсивной функции базового случая. 
Вот сама реализация нашего trampoline:

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Library/TailRecursion.cs}
	\caption{\texttt{TailRecursion.cs} - Статический класс для оптимизации хвостовой рекурсии (trampoline).}
\end{code}

И есть класс, который является контейнером для текущего состояния нашей рекурсии:

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Library/RecursionResult.cs}
	\caption{\texttt{RecursionResult.cs} - Контейнер состояния рекурсии.}
\end{code}

\newpage
\section{Тестирование}

Были произведены тесты на основе фреймворка xUnit для юнит-тестирования:

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Tests/SumUnitTest.cs}
	\caption{\texttt{SumUnitTest.cs} - тестирование суммы ряда.}
\end{code}

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Tests/PiSeriesUnitTest.cs}
	\caption{\texttt{PiSeriesUnitTest.cs} - тестирование вычисления приближенного значения числа $\pi$.}
\end{code}

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Tests/SqrtUnitTest.cs}
	\caption{\texttt{SqrtUnitTest.cs} - тестирование вычисления квадратного корня с помощью метода Герона и метода нахождения неподвижной точки.}
\end{code}

\begin{code}
	\inputminted[tabsize=2,breaklines]{csharp}{src/Tests/EquationSolverUnitTest.cs}
	\caption{\texttt{EquationSolverUnitTest.cs} - тестирование нахождения корней уравнения с помощью метода Ньютона и метода бисекций.}
\end{code}

Все юнит-тесты успешно проходят тестирование.

\newpage
\section{Характеристики ПК}

Все тесты были произведены на ПК с такими характеристиками:

\begin{itemize}
	\item ЦПУ - \texttt{Intel(R) Core(TM) i5-8265U CPU}:
	\begin{enumerate}
		\item Базовая скорость: 1.8 ГГц
		\item Количество ядер: 4
		\item Кэш первого уровня: 256 Кб
		\item Кэш второго уровня: 1 Мб
		\item Кэш третьего уровня: 6 Мб
	\end{enumerate}
	\item ОЗУ:
	\begin{enumerate}
		\item Объём: 16 Гб
		\item Скорость: 2400 МГц
	\end{enumerate}
	\item ЗУ - \texttt{Samsung SSD 970 EVO Plus}
	\begin{enumerate}
		\item Объём: 250 Гб
		\item Среднее время отклика: 1.1 мс
	\end{enumerate}
\end{itemize}

\newpage
\section*{Заключение}
В данной работе было показано, как использовать принципы и концепции функционального программирования на примере построение системы вычисления числовых рядов.

Из кода понятно, что громоздкие типы \texttt{Func<\dots,\dots>} являются нечитабельными, и языку \texttt{C\#} требуется выведение типов.
Этого можно добиться тем, чтобы в язык были добавлены шаблоны, или некие макросы, которые добавили бы элементы метапрограммирования, когда на этапе компиляции мы могли выводить типы, а то и вычислять функции.
Только представьте всю мощность функционального программирования и метапрограммирования, когда мы можем уже на этапе компиляции сказать, что данная функция не может быть вычислена из-за ошибки программиста.
Естественно не каждую рекурсивную функцию можно вычислить с помощью метапрограммирования бесплатно.
Плата за константное вычисление любой рекурсивной функции, запрограммированой с помощью шаблонов является долгая компиляция.

В данной работе было показано, как реализовать простейшую оптимизацию хвостовой рекурсии, которую можно было бы добавить в этап оптимизации кода компилятором.
Но разработчики \texttt{C\#} думают, что необходимо использовать не рекурсию, а пользоваться циклами.
\addcontentsline{toc}{section}{Заключение}
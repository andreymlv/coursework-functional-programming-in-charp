\section*{Введение}

В данной курсовой работе будут показаны возможности и недостатки языка C\# в плане вычисления математических функций.
В частности, будет сравнение алгоритмов вычисления одной и той же функции применяя разные парадигмы программирования.
Сравним оптимизацию хвостовой рекурсией, обычную рекурсию, императивный стиль, а так же воспользуемся стандартными средствами языка C\# для того, чтобы вычислить функцию.
Будет показано, как разработать комплекс функций, которые являются функциями высшего порядка.

По сей день люди решают уравнения (находят корни уравнения), находят суммы или произведения рядов, поэтому данная работа является актуальной.

Цель данной работы - изучение основ функциональной парадигмы программирования, применение принципов функционального программирования с помощью языка C\#.

Задачи:

\begin{itemize}
	\item Изучить литературу по данной теме.
	\item Изучить методы и алгоритмы решения задачи.
	\item Описать сложность для каждого представленного алгоритма в $O$-нотации.
\end{itemize}
\addcontentsline{toc}{section}{Введение}

\newpage
\section{Функциональная парадигма программирования}

\subsection{История}

Первый высокоуровневый функциональный язык программирования LISP был разработан в конце 1950-х годов для научных компьютеров серии IBM 700/7000 Джоном Маккарти, когда он учился в Массачусетском технологическом институте (MIT). \cite{HistoryofLISP}

Язык обработки информации (IPL), 1956, иногда упоминается как первый функциональный язык программирования.
Это язык в стиле ассемблера для работы со списками символов. \cite{ModelsofMyLife}
В нём действительно есть понятие генератора, которое сводится к функции, которая принимает функцию в качестве аргумента, и, поскольку это язык уровня ассемблера, то код может быть данными, поэтому IPL можно рассматривать как язык, имеющий функции более высокого порядка.

В 1970-х годах Гай Л. Стил и Джеральд Джей Сассман разработали язык Scheme, и использовали его в своём курсе, основанном на книге 1985 года "Структура и интерпретация компьютерных программ"\cite{SICP}.
Scheme был первым диалектом LISP, который использовал лексическую область видимости и требовал оптимизацию хвостовой рекурсией, которые рекомендуются в функциональном программировании.
Книга обучает фундаментальными принципами компьютерного программирования, включая рекурсию, абстракцию, модульность, проектирование и реализация языков программирования.

\subsection{Функциональное программирование}

Функциональное программирование - это:

\begin{itemize}
	\item парадигма программирования, характеризующаяся использованием математических функций и избеганием побочных эффектов.
	\item стиль программирования, который использует только чистые функции без побочных эффектов.
\end{itemize}

Побочные эффекты - это всё, что делает функция, кроме возврата значения, например:

\begin{enumerate}
	\item Отправка электронного письма.
	\item Чтение файла.
	\item Выполнение веб-запроса.
\end{enumerate}

Побочные эффекты приводят к тому, что программист не может предсказать, что произойдёт в его программе.

Чистые функции - это функции, которые зависят только от своих аргументов и не имеют никаких побочных эффектов.
Одни и те же аргументы всегда будут выдавать одно и то же возвращаемое значение.

Из определения можно подумать, что функциональные языки программирования не имеют грязных функций.
Но это не так - такой язык бесполезен в реальном мире.
Вход в мир грязных функций красиво реализован в языке Haskell, там для таких целей используются монады, с помощью которых мы делаем обёртку над грязным миром.

\subsection{Концепции}

В целом можно выделить несколько инструментов (концептов) функционального программирования, это:

\begin{itemize}
	\item Функции первого класса и функции высшего порядка.
	\item Чистые функции.
	\item Рекурсия.
	\item Строгая и нестрогая вычислительная система.
\end{itemize}

\subsubsection{Функции высшего и первого порядка}

В математике и компьютерных науках функция высшего порядка - это функция, которая выполняет по крайней мере одно из следующих действий:

\begin{itemize}
	\item принимает одну или несколько функций в качестве аргументов,
	\item возвращает функцию в качестве результата.
\end{itemize}

Все остальные функции являются функциями первого класса.

\subsubsection{Чистые функции}

Чистые функции (или выражения) не имеют побочных эффектов (прямая работа с памятью или вводом-выводом).
Это означает, что чистые функции обладают несколькими полезными свойствами, многие из которых могут быть использованы для оптимизации кода:

\begin{itemize}
	\item Если результат чистого выражения не используется, его можно удалить, не затрагивая другие выражения.
	\item Если вызывается чистая функция с аргументами, которые не вызывают побочных эффектов, результат остается постоянным по отношению к этому списку аргументов (иногда вызывается ссылочная прозрачность или идемпотентность), т.е. повторный вызов чистой функции с теми же аргументами возвращает тот же результат. (Это может быть использовано для оптимизацией кэшированием)
	\item Если между двумя чистыми выражениями нет зависимости от данных, их порядок может быть изменен на противоположный, или они могут выполняться параллельно, и они не могут мешают друг другу (другими словами, вычисление любого чистого выражения является потокобезопасным).
	\item Если весь язык не допускает побочных эффектов, то можно использовать любую стратегию вычисления (следующая концепция, которую мы рассмотрим); это дает компилятору свободно изменять порядок или комбинировать вычисление выражений в программе (компилятор может так применить дефорестацию - избегание построения новых структур данных в программе).
\end{itemize}

\subsubsection{Рекурсия}

Итерация (цикл) в функциональных языках обычно выполняется с помощью рекурсии.
Рекурсивные функции вызывают сами себя, позволяя повторять операцию до тех пор, пока она не достигнет базового варианта.
В общем случае рекурсия требует поддержания стека, который потребляет пространство в линейной зависимости от глубины рекурсии.
Это может сделать рекурсию непомерно дорогой для использования вместо императивных циклов.
Однако особая форма рекурсии, известная как хвостовая рекурсия, может быть распознана и оптимизирована компилятором в том же коде, который использовался для реализации итерация в императивных языках.
Оптимизация хвостовой рекурсии может быть реализована, среди прочего, путем преобразования программы в стиль передачи продолжения во время компиляции.

\subsubsection{Стратегия вычисления}

Функциональные языки можно классифицировать по тому, используют ли они строгое (незамедлительное) или нестрогое (ленивое) вычисление, это понятия, которые относятся к тому, как аргументы функций вычисляются при вычислении самой функции.

Например:

\begin{code}
	\lstinputlisting[language=Python]{listings/evaluation.py}
\end{code}

Данное выражение не проходит строгое вычисление из-за деления на ноль в третьем элементе списка.
При ленивом вычислении функция длины возвращает значение 4 (т.е. количество элементов в списке), поскольку при ее вычислении не предпринимается попытка вычисления внутренних выражений, составляющие список.
Короче говоря, строгая оценка всегда полностью оценивает аргументы функции перед вызовом функции.
Ленивая оценка не вычисляет аргументы функции, если только их значения не требуются для вычисления самой функции.


\newpage
\section{Выбор программного обеспечения}

\subsection{Язык программирования}

Так как идея разработки пришла из прочтения книг про функциональное программирование, то и было бы логично применять в данной работе языки, которые являются либо частично функциональными, либо чисто функциональными.

Но одно из требований написания курсовой работы - применять язык программирования C\#, который не является функциональным.
В нём есть инструменты, с помощью которых можно писать функциональные методы, но это приходится всё обёртывать в статические классы, которые служат собой обычным именованным пространством.

Из-за требований работы невозможно рассматривать альтернативу C\#.

На данный момент существует функциональный язык программирования F\#, который может запускать C\# код.

\subsection{Операционная система}

На сегодняшний день почти все языки программирования имеют кроссплатформенную поддержку почти всех популярных операционных систем (BSD, Windows, Linux, MacOS).

Разработка велась на операционной системе Windows 10.

\subsection{Инструменты}

В качестве инструмента написания программ было выбрано несколько программ:

\begin{itemize}
	\item Microsoft Visual Studio
	\item Microsoft Visual Studio Code
	\item JetBrains Rider
\end{itemize}

Microsoft Visual Studio поставляет компилятор и интерпретатор для языка C\# под операционную систему Windows.

Microsoft Visual Studio Code является легковесным редактором текста.
В нём есть удобные расширения, с помощью которых я исправлял грамматические ошибки в комментариях к каждому методу.

JetBrains Rider является моим основным средством разработки.
Платный, но для студентов предоставляется студенческая бесплатная лицензия.
В этой среде разработки имеется удобный дебаггер, статический анализатор кода, который помогает найти ошибки в самом тесте кода.
Удобные подсказки и автозаполнение кода увеличивают скорость и качество разработки кода.

В качестве системы контроля версий был выбран Git.
Является стандартом в современной разработке софта.
Весь текст курсовой работы и сам проект находится на сервисе GitHub\cite{GitHub}.

\newpage
\section{Проектирование}

При проектировании были использованы некоторые аспекты гибкой методологии разработки программного обеспечения.

В частности, была установлена основная функциональность проекта:

\begin{enumerate}
	\item Разработка функций высшего порядка, которые решали сумму или произведение рядов любых функций.
	\item Разработка двух методов решения уравнений с помощью рекурсии (метод касательных и метод бисекций).
	\item Разработка оптимизации хвостовой рекурсией.
\end{enumerate}

\newpage
\section{Разработка}

Для демонстрации мощности функционального программирования я создал статический класс Sequence, который является модулем, в котором есть функции нахождения суммы/произведения рядов. 

\begin{code}
	\lstinputlisting[language=Java]{../project/CourseWork/Library/Sequence.cs}
	\caption{Sequence.cs - Статический класс для создания любых рядов.}
\end{code}

Такой класс создаёт больше поле стратегий для вычислений любого ряда.

Можно задать любой шаг. Можно задать любую функцию, которая описывает общий элемент последовательности. Любой знак между общими членами. Любой аккумулятор, который будет накапливать значение.

Таким образом можно создать класс, который "реализует" некоторые части нашей последовательности. Например, класс "сумма ряда":

\begin{code}
	\lstinputlisting[language=Java]{../project/CourseWork/Library/Sum.cs}
	\caption{Sum.cs - Статический класс для создания любых рядов суммы.}
\end{code}

Аналогичным образом был разработал класс "произведения ряда":

\begin{code}
	\lstinputlisting[language=Java]{../project/CourseWork/Library/Product.cs}
	\caption{Product.cs - Статический класс для создания любых рядов произведения.}
\end{code}

Эти классы показывают как можно легко построить систему, в основе которой лежит более общая "идея".
Идея суммы ряда это частный случай любой последовательности.

\newpage
\section{Тестирование}

Были произведены тесты на основе фреймворка xUnit для юнит-тестирования:

\begin{code}
	\lstinputlisting[language=Java]{../project/CourseWork/Tests/SumUnitTest.cs}
	\caption{SumUnitTest.cs - тестирование суммы ряда.}
\end{code}

\begin{code}
	\lstinputlisting[language=Java]{../project/CourseWork/Tests/SqrtUnitTest.cs}
	\caption{SqrtUnitTest.cs - тестирование вычисления квадратного корня с помощью метода Герона.}
\end{code}

Все юнит-тесты успешно проходят тестирование.

\newpage
\section{Характеристики ПК}

Все тесты были произведены на ПК с такими характеристиками:

\begin{itemize}
	\item ЦПУ - Intel(R) Core(TM) i5-8265U CPU:
	\begin{enumerate}
		\item Базовая скорость: 1.8 ГГц
		\item Количество ядер: 4
		\item Кэш первого уровня: 256 Кб
		\item Кэш второго уровня: 1 Мб
		\item Кэш третьего уровня: 6 Мб
	\end{enumerate}
	\item ОЗУ:
	\begin{enumerate}
		\item Объём: 16 Гб
		\item Скорость: 2400 МГц
	\end{enumerate}
	\item ЗУ - Samsung SSD 970 EVO Plus
	\begin{enumerate}
		\item Объём: 250 Гб
		\item Среднее время отклика: 1.1 мс
	\end{enumerate}
\end{itemize}

\newpage
\section*{Заключение}
В данной работе было показано, как использовать принципы и концепции функционального программирования на примере построение системы вычисления числовых рядов.
\addcontentsline{toc}{section}{Заключение}